<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Single qubit control · GOAT.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="GOAT.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="GOAT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GOAT.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../background/Overview/">Background</a></li><li><span class="tocitem">Structure</span><ul><li><a class="tocitem" href="../../core/Ansatz/">Control Ansatze</a></li><li><a class="tocitem" href="../../core/DataStructures/">Core data structures</a></li><li><a class="tocitem" href="../../core/Methods/">Finding optimal controls</a></li><li><a class="tocitem" href="../../core/ReferenceFrames/">Reference frames</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Single qubit control</a><ul class="internal"><li><a class="tocitem" href="#Imports"><span>Imports</span></a></li><li><a class="tocitem" href="#Defining-the-ControllableSystem"><span>Defining the <code>ControllableSystem</code></span></a></li><li><a class="tocitem" href="#Defining-the-QOCProblem"><span>Defining the <code>QOCProblem</code></span></a></li><li><a class="tocitem" href="#Defining-a-reduction-map"><span>Defining a reduction map</span></a></li><li><a class="tocitem" href="#Specifying-solver-and-optimization-options"><span>Specifying solver and optimization options</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-the-initial-guess-and-perform-an-optimization"><span>Define the initial guess and perform an optimization</span></a></li></ul></li><li><a class="tocitem" href="../example2/">Working with QuantumOptics.jl</a></li></ul></li><li><a class="tocitem" href="../../recommendations/">Recommendations</a></li><li><a class="tocitem" href="../../core/API_reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Single qubit control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Single qubit control</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MCS-Quantum/GOAT.jl/blob/main/docs/src/examples/example1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimizing-a-gaussian-pulse-for-a-single-qubit"><a class="docs-heading-anchor" href="#Optimizing-a-gaussian-pulse-for-a-single-qubit">Optimizing a gaussian pulse for a single qubit</a><a id="Optimizing-a-gaussian-pulse-for-a-single-qubit-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-a-gaussian-pulse-for-a-single-qubit" title="Permalink"></a></h1><p>This is perhaps the simplest example of a quantum optimal control problem. The physical task is to invert a qubit&#39;s population from he ground state <span>$\ket{0}$</span> to the orthogonal state <span>$\ket{1}$</span>.</p><p>Given a qubit Hamiltonian </p><p class="math-container">\[H(t) = \frac{\omega}{2}\sigma_z + \Omega(t)\sigma_x\]</p><p>one can determine analytically that there are a family of pulses which will accomplish the control task if the following criteria is met:</p><p class="math-container">\[\int_0^t d\tau \Omega(\tau) = \pi\]</p><p>one common choice of <span>$\Omega(t)$</span> is a Gaussian function (due to an array of reasons outside the scope of this example). </p><p>For this example we will fix the mean and standard deviation of the Gaussian to <span>$\mu=T/2$</span> and <span>$\sigma = T/8$</span>. Therefore, we must determine the amplitude of the Gaussian in order to satisfy the topological criteraia and create population inversion.</p><h2 id="Imports"><a class="docs-heading-anchor" href="#Imports">Imports</a><a id="Imports-1"></a><a class="docs-heading-anchor-permalink" href="#Imports" title="Permalink"></a></h2><pre><code class="language- hljs">using GOAT
using LinearAlgebra, SparseArrays # For instantiating necessary matrices
using OrdinaryDiffEq # Load differetial equation algorithms
using Optim, LineSearches # Load optimization and linesearch algorithms</code></pre><h2 id="Defining-the-ControllableSystem"><a class="docs-heading-anchor" href="#Defining-the-ControllableSystem">Defining the <code>ControllableSystem</code></a><a id="Defining-the-ControllableSystem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-ControllableSystem" title="Permalink"></a></h2><p>We begin by defining the necessary operators for the Hamiltonian</p><pre><code class="language-julia hljs">σx = sparse(ComplexF64[0 1 ; 1  0])# The Pauli X matrix
σy = sparse(ComplexF64[0 -im ; im 0]) # The Pauli Y matrix
σz = sparse(ComplexF64[1 0 ; 0 -1]) # The Pauli Z matrix
σI = sparse(ComplexF64[1 0 ; 0  1]) # The identity matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
 1.0+0.0im      ⋅    
     ⋅      1.0+0.0im</code></pre><p>Next we define the Hamiltonian parameters and the control basis operators</p><pre><code class="language-julia hljs">ω = 5*2pi # Setting a qubit frequency
T = 10.0 # in arbitrary time units
H0 = (ω/2)*σz # Setting the drift component of the Hamiltonian
basis_ops = [σx] # The control basis operator</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}:
 sparse([2, 1], [1, 2], ComplexF64[1.0 + 0.0im, 1.0 + 0.0im], 2, 2)</code></pre><p>Next we choose a control ansatz specifying only a single basis function</p><pre><code class="language-julia hljs">N_basis_funcs = 1
Ω(p,t,i) = gaussian_coefficient(p,t,i,N_basis_funcs)*cos(ω*t) # The control ansatz is a gaussian envelope of a cosine wave at frequency ω
∂Ω(p,t,i,l) = ∂gaussian_coefficient(p,t,i,l,N_basis_funcs)*cos(ω*t) # The derivative of the control ansatz</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">∂Ω (generic function with 1 method)</code></pre><p>and specify a rotating frame</p><pre><code class="language-julia hljs">rotating_frame_generator = -Diagonal(Matrix(H0)) # Moving into the interaction picture</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}:
 -15.708-0.0im         ⋅    
         ⋅      15.708-0.0im</code></pre><p>Finally we are able to specify our <code>ControllableSystem</code>:</p><pre><code class="language-julia hljs">sys = ControllableSystem(H0, basis_ops, rotating_frame_generator, Ω, ∂Ω)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControllableSystem{Vector{Int64}, Vector{ComplexF64}, typeof(Main.Ω), typeof(Main.∂Ω), LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}}([1, 2], [1, 2], ComplexF64[15.707963267948966 + 0.0im, -15.707963267948966 + 0.0im], [[2, 1]], [[1, 2]], Vector{ComplexF64}[[1.0 + 0.0im, 1.0 + 0.0im]], Main.Ω, Main.∂Ω, ComplexF64[-15.707963267948966 - 0.0im 0.0 + 0.0im; 0.0 + 0.0im 15.707963267948966 - 0.0im], ComplexF64[0.0 + 6.9232299288966e-310im 0.0 + 0.0im; 0.0 + 0.0im 6.9232299274784e-310 + 0.0im], true, 2, false, 0.0)</code></pre><h2 id="Defining-the-QOCProblem"><a class="docs-heading-anchor" href="#Defining-the-QOCProblem">Defining the <code>QOCProblem</code></a><a id="Defining-the-QOCProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-QOCProblem" title="Permalink"></a></h2><p>First we define our target unitary operator</p><pre><code class="language-julia hljs">U_target = deepcopy(σx) # The targt unitary: X|0&gt; = |1&gt;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      1.0+0.0im
 1.0+0.0im      ⋅    </code></pre><p>Now, we provide a projector onto the computational and ancillary subspaces</p><pre><code class="language-julia hljs">Pc = σI # The projector onto the computational subspace (which is the whole Hilbert space in this case)
Pa = 0.0*Pc # The projector onto the ancillary subspaces (which is a null operator in this case)
prob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QOCProblem(ComplexF64[1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im], 2, ComplexF64[0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im], 0, ComplexF64[0.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 0.0 + 0.0im], 10.0)</code></pre><h2 id="Defining-a-reduction-map"><a class="docs-heading-anchor" href="#Defining-a-reduction-map">Defining a reduction map</a><a id="Defining-a-reduction-map-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-reduction-map" title="Permalink"></a></h2><p>A reduction map defines how the output from the Schrodinger equation (SE) and the GOAT EOMs are manipulated to return the objective function and any associated derivatives. Here we will use an already implemented reduction map that computes a projective SU measure called &quot;infidelity.&quot;</p><pre><code class="language-julia hljs">SE_reduce_map = SE_infidelity_reduce_map
GOAT_reduce_map = GOAT_infidelity_reduce_map</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GOAT_infidelity_reduce_map (generic function with 1 method)</code></pre><h2 id="Specifying-solver-and-optimization-options"><a class="docs-heading-anchor" href="#Specifying-solver-and-optimization-options">Specifying solver and optimization options</a><a id="Specifying-solver-and-optimization-options-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-solver-and-optimization-options" title="Permalink"></a></h2><pre><code class="language- hljs"># Define options for DifferentialEquations.jl (see DifferentialEquations.jl docs for info)
ODE_options = (abstol = 1e-9, reltol= 1e-9, alg=Vern9())

# Define the optimizer options from Optim.jl (See Optim.jl docs for info)
optim_alg = Optim.LBFGS(linesearch=LineSearches.BackTracking()) # A Back-Tracking linesearch
optim_options = Optim.Options(g_tol=1e-12,
                            iterations=10,
                            store_trace=true,
                            show_trace=true, extended_trace=false, allow_f_increases=false)</code></pre><h1 id="Define-the-initial-guess-and-perform-an-optimization"><a class="docs-heading-anchor" href="#Define-the-initial-guess-and-perform-an-optimization">Define the initial guess and perform an optimization</a><a id="Define-the-initial-guess-and-perform-an-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-initial-guess-and-perform-an-optimization" title="Permalink"></a></h1><p>Here we will define our initial guess and specify which parameters are to be optimized, and how parallelization is to proceed:</p><pre><code class="language-julia hljs">p0 = [0.5,T/2,T/8] # The initial parameter guesses
opt_param_inds = [1] # The parameters of the vector p0 to optimize (just the amplitude parameter -- p0[1] -- in this case)
num_params_per_GOAT = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>This <code>num_params_per_GOAT</code> variable specifies how many derivatives are propogated in each GOAT EOMs and informs parallelization. </p><p>For example, if <code>num_params_per_GOAT=5</code>and there are 5 total parameters, then no parallelization is performed. In contrast, if <code>num_params_per_GOAT=2</code> and the  re are 5 total parameters, then 3 processes are run in parallel: the first processor computes the EOMs for 2 parameters, the second process computes the EOMs for 2 parameters, and the third computes the EOMs for 1 parameter. </p><p>Next we put all of these parameters into a <code>QOCParameters</code> struct:</p><pre><code class="language- hljs">params = QOCParameters(ODE_options,SE_reduce_map,GOAT_reduce_map,optim_alg,optim_options; num_params_per_GOAT=num_params_per_GOAT)</code></pre><p>Finally we run our optimization</p><pre><code class="language- hljs">res = find_optimal_controls(p0, opt_param_inds, sys, prob, params)
res</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../core/ReferenceFrames/">« Reference frames</a><a class="docs-footer-nextpage" href="../example2/">Working with QuantumOptics.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 2 May 2023 16:23">Tuesday 2 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
