var documenterSearchIndex = {"docs":
[{"location":"background/Overview/#The-GOAT-method","page":"Background","title":"The GOAT method","text":"","category":"section"},{"location":"background/Overview/","page":"Background","title":"Background","text":"The task of unitary quantum optimal control is to determine a set of control parameters vecalpha that realize a desired unitary evolution on the quantum system. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"Specifically, the dynamics under the Hamiltonian","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"H(vecalphat)  = H_0 + sum_i c_i(vecalphat) H_i","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"generates a unitary evolution","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"U(vecalphat) = mathcalTexp bigg int_0^t dtau H(vecalphatau) bigg","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"The task of optimal control is to determine a set of control parameters vecalpha^* and a control time T^* such that the system's evolution U(vecalpha^* T^*) approximates a desired unitary evolution U_target. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"While this optimization can be performed using gradient-free methods, algorithms that utilize information about the gradient of the objective function w.r.t. the control parameters can yield much faster optimization. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"In order to utilize gradient-based optimization routines it is required that we compute the partial derivative of the unitary evolution with respect to a particular parameter alpha_n: partial_alpha_n U(vecalphaT). This can then be used (via the chain rule) to compute gradients of the objective function. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"We compute partial_alpha_n U(vecalphaT) by deriving a new differential equation from the Schrodinger equation:","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"ihbar partial_t U(vecalphat) = H(vecalphat)U(vecalphat)","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"by differentiating w.r.t alpha_n and utilizing the product rule","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"beginalign*\nihbarpartial_alpha_n partial_t U(vecalphat) = bigg(partial_alpha_n H(vecalphat) bigg) U(vecalphat) + bigg( H(vecalphat) bigg) partial_alpha_nU(vecalphat)\n= ihbarpartial_t partial_alpha_n U(vecalphat)\nendalign*","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"The last step utilizes the symmetry of the second derivative to obtain a differential equation for partial_alpha_n U(vecalphat). ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"To compute partial_alpha_n U(vecalphaT) at a final time T, we integrate the coupled differential equations:","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"\npartial_t\nbeginpmatrix\nU(vecalphat)\npartial_alpha_n U(vecalphat)\nendpmatrix\n\n= \n\nbeginpmatrix\nH(vecalphat)  0\npartial_alpha_n H(vecalphat)  H(vecalphat)\nendpmatrix\n\nbeginpmatrix\nU(vecalphat)\npartial_alpha_n U(vecalphat)\nendpmatrix","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"This coupled differential equation is referred to as the GOAT equations of motion (EOMs). The initial conditions are U(vecalpha0) = I and partial_alpha_n U(vecalpha0) = 0  forall   alpha_n. It has a significant amount of internal structure which is specialized on in this package for efficient computation.","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"First, it depends only on a single parameter alpha_n thus, computing the gradient can be obtained through parallelization, solving a seperate GOAT EOM for each parameter to be optimized. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"Second, the action of the differential equation is highly structured: the upper triangle of the matrix is null and the diagonal of the matrix is H(vecalphat). Thus, storing this matrix, even in a sparse form is inefficient. Not only that, but the Hamiltonians of most physically realizable quantum systems are sparse which suggests that instantiating the action of the EOMs is not efficient in general. ","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"Thus, this package specializes on these structures to implement parallelized, matrix-free implementations of the GOAT EOMs to optimize performance. ","category":"page"},{"location":"background/Overview/#Matrix-free-implementation","page":"Background","title":"Matrix-free implementation","text":"","category":"section"},{"location":"background/Overview/","page":"Background","title":"Background","text":"Here we specify the matrix-free, in-place implementation of the GOAT equations of motion:","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"When solving the GOAT EOMs using OrindaryDiffEq we need to generate a function f(du,u,p,t) that efficiently computes the derivative:","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"\npartial_t\nbeginpmatrix\nU(vecalphat)\npartial_alpha_n U(vecalphat)\nendpmatrix\n","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"However, there are a number of ways to accelerate this, first we can peform the operation in-place, pre-allocating du and overwritting the matrix elements during the computation. This could be simply done via in-place matrix multiplication, however that would require allocating an array for the generator as a matrix at every time t:","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"\nbeginpmatrix\nH(vecalphat)  0\npartial_alpha_n H(vecalphat)  H(vecalphat)\nendpmatrix\n","category":"page"},{"location":"background/Overview/","page":"Background","title":"Background","text":"This is unnecessary because there are static components to the Hamiltonian and the generator of the GOAT EOMs is very redundant, as mentioned above. So, we specialize further and automatically generate matrix-free methods for f!(du,u,p,t) that do not allocate any intermediate arrays. Moreover, we minimize access to the pre-allocated arrays and eliminate redundant computation of the time-dependent coefficients by optimizing the in-place matrix multiplication methods. ","category":"page"},{"location":"core/DataStructures/#Core-data-structures","page":"Core data structures","title":"Core data structures","text":"","category":"section"},{"location":"core/DataStructures/#ControllableSystem","page":"Core data structures","title":"ControllableSystem","text":"","category":"section"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"Performing a quantum optimal control simulation requires various inputs and options. We must specify the quantum system and how it is controlled, specify the optimal control problem objective, and we define the methods and parameters for both the optimization routines and the solution of the differential equations. ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"In GOAT.jl we specify all of this required information into three core structures: ControllableSystem, QOCProblem, and QOCParameters. ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"The first is ControllableSystem, which holds all the information about how the quantum system evolves with a given set of control parameters and even holds information regarding the reference frame that the evolution is being computed in. We do not anticipate most users to delve into the structure of ControllableSystem so we provide a number of methods to generate this structure in a less complex manner. ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"As an example, consider a controllable system with a simple structure that we wish to use for gradient-based quantum optimal control:","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"H(vecalphat)  = H_0 + sum_i c_i(vecalphat) H_i","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"first we define the operators","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"drift = H0\ncontrol_basis_ops = [H1,H2,H3] # Just a vector of matrices","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"then we define the coefficient function and its derivative w.r.t. the control parameters (See Ansatze section). For simplicity we will assume that each coefficient is the sum of N=3 Gaussian functions, each with variable amplitude, mean, and standard deviation:","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"c_func(p,t,i,N) = gaussian_coefficient(p,t,i,3)\n∂c_func(p,t,i,l,N) = gaussian_coefficient(p,t,i,l,3)","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"Then we will call the following method:","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"sys = ControllableSystem(H0,control_basis_ops,c_func,∂c_func)","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"This will automatically convert all of the arrays into a sparse format which will enable GOAT.jl to generate optimized functions for computing the GOAT EOMs. ","category":"page"},{"location":"core/DataStructures/#QOCProblem","page":"Core data structures","title":"QOCProblem","text":"","category":"section"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"GOAT.jl provides the ability to solve quantum-process QOC tasks. These are tasks where the goal is to identify a set of controls that will cause the system to undergo a desired quantum process. This includes objectives where the goal is to generate a unitary evolution on the global Hilbert space, an arbitrary quantum process on a subspace, or perform initial-state specific tasks. ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"The output from any solution to the Schrodinger equation or GOAT EOMs is a unitary operator on the full Hilbert space. The QOCProblem structure specifies what the objective function and the duration of the controls. ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"For example, given a target unitary to implement U_target and a total control time T we can define the problem as:","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"Pc = σI # The projector onto the computational subspace (which is the whole Hilbert space in this case)\nPa = 0.0*Pc # The projector onto the ancillary subspaces (which is a null operator in this case)\nprob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem. ","category":"page"},{"location":"core/DataStructures/#QOCParams","page":"Core data structures","title":"QOCParams","text":"","category":"section"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"While ControllableSystem and QOCProblem define what the system is and what we are trying to accomplish via QOC, respectively, we also need to specify how the computation will proceed. That is where QOCParams comes into play.","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"Specifically, QOCParams has a relatively simple structure:","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"struct QOCParameters\n    ODE_options\n    SE_reduce_map\n    GOAT_reduce_map\n    optim_alg\n    optim_options\n    num_params_per_GOAT\nend","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"ODE_options is a NamedTuple specifying the solver options for OrdinaryDiffEq.jl, SE_reduce_map and GOAT_reduce_map are functions that take the output unitaries from solving the differential equations and map to the objective functions and gradients, optim_alg and optim_options are the options for Optim.jl, and num_params_per_GOAT specifies how many gradients are propogated per CPU (effectively defining the parallelization of the QOC problem). ","category":"page"},{"location":"core/DataStructures/","page":"Core data structures","title":"Core data structures","text":"Any user is strongly encouraged to view the examples for a detailed description of how to specify each of these parameters. ","category":"page"},{"location":"examples/example2/#Optimizing-a-custom-pulse-ansatz-for-a-transmon-using-QuantumOptics.jl","page":"Working with QuantumOptics.jl","title":"Optimizing a custom pulse-ansatz for a transmon using QuantumOptics.jl","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example we will utilize QuantumOptics.jl to define a more complex quantum system – a Duffing oscillator (a good model of a Transmon). We will also define a custom pulse ansatz using some of the pre-defined basis functions in GOAT.jl.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"The quantum systems that people deal with in a laboratory are very often not qubits. Instead, one defines a qubit subspace within the quanutm system you have access to. For example, a duffing oscillator has the Hamiltonian:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H = omega hatn+fracdelta2 hatn(hatn-1)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"where the frequency of the oscillator is specified by omega and delta defines the anharmonicity (it adds a perturbation that makes different energy levels of the oscillator have different transition frequencies). ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"This system has an infinite number of eigenstates that form a ladder-like structure. However, we can define a \"qubit\" within a 2-dimensional subspace. For instance, we can choose the subspace spanned by the two lowest energy eigenstates: 0 rangle 1rangle . ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example, we will use GOAT.jl to find a optimal control that implements a pi rotation within this subspace (i.e, find a unitary V s.t. V0rangle propto 1rangle and V1rangle propto 0rangle). This is a much more challenging task than the one explored in Example 1. In particular, we must make sure that the unitary V does not connect (or minimially connects) the 0rangle or 1rangle states to any other states of the oscillator. This is a process called leakage. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Our control term has the form ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H_c(t) = Omega(t)(hata + hata^dagger) ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Where hata and hata^dagger are the excitation anhilation and creation operators, respectively. ","category":"page"},{"location":"examples/example2/#Imports","page":"Working with QuantumOptics.jl","title":"Imports","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"using GOAT\nusing QuantumOptics\nusing LinearAlgebra, SparseArrays # For instantiating necessary matrices\nusing OrdinaryDiffEq # Load differetial equation algorithms\nusing Optim, LineSearches # Load optimization and linesearch algorithms","category":"page"},{"location":"examples/example2/#Defining-the-ControllableSystem-using-QuantumOptics.jl","page":"Working with QuantumOptics.jl","title":"Defining the ControllableSystem using QuantumOptics.jl","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We first define a Hilbert space using QuantumOptics and then the operators that live on that space:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"b = FockBasis(3) # A Hilbert space basis using a particle-number cutoff of 3 : span(|0⟩, |1⟩, |2⟩, |3⟩)\na = destroy(b) # The particle anhilation operator\nat = create(b) # The particle creation operator\nn = number(b) # The particle number operator\nId = identityoperator(b) # The identity operator","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next, we define the Hamiltonian parameters","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"ω = 5*2pi # Setting a oscillator frequency\nδ = -0.2*2pi # Setting the oscillator anharmonicity \nT = 20.0 # in arbitrary time units","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"And finally the Hamiltonian and the control basis operators. (we access the underlying matrix of the QuantumOptics operator using \".data\" attribute)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H0 = (ω*n+ 0.5*δ*n*(n-Id)).data # Setting the drift component of the Hamiltonian \nHc = (a+at).data\nbasis_ops = [Hc] # The operators which define the control basis","category":"page"},{"location":"examples/example2/#Defining-a-custom-ansatz","page":"Working with QuantumOptics.jl","title":"Defining a custom ansatz","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We will now define a custom pulse ansatz consisting of a sum of sinusoid functions that are modulated with an envelope function that is a flat-topped-cosine. Each ansatz has a different number of parameters for each basis function. For the Fourier basis the parameters are the amplitude, frequency, and phase of each sinusoid. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"N = 1 # The number of basis functions to use to describe the control. \nfunction Ω(p,t,i)\n    envelope = flat_top_cosine(t,1,T,0.3*T) # A flat-top cosine envelope for our pulse\n    c = fourier_coefficient(p,t,i,N) # The control ansatz is a sum of sinusoidal basis functions\n    return c*envelope\nend\n    \nfunction ∂Ω(p,t,i,l)\n    envelope = flat_top_cosine(t,1,T,0.3*T) # A flat-top cosine envelope for our pulse\n    ∂c = ∂fourier_coefficient(p,t,i,l,N) # The derivative of the control ansatz\n    return ∂c*envelope\nend","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We now define the reference frame in which we will implement a desired unitary operator:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"rotating_frame_generator = -Diagonal(Matrix(H0)) # Moving into the reference frame rotating at the oscillator frequencies","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"And finally we define the ControllableSystem:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"sys = ControllableSystem(H0, basis_ops, rotating_frame_generator, Ω, ∂Ω)","category":"page"},{"location":"examples/example2/#Defining-the-QOCProblem","page":"Working with QuantumOptics.jl","title":"Defining the QOCProblem","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example, we wish to generate a unitary operator within a subspace of the system's Hilbert space. This requires that the global unitary operator (which is what we compute by solving the Schrodinger Equation and GOAT EOMs) be block-diagonal with respect to a bipartion of the Hilbert space. We reinforce this constrating by specifying the projectors onto the computational and ancillary subspaces. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Pc = (projector(fockstate(b,0))+projector(fockstate(b,1))).data # The projector onto the computational subspace \n# (which is the first two energy levels in this case: |0⟩, |1⟩)\nPa = 0.0*Id.data # The projector onto the ancillary subspaces (which is a null operator in this case)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"the projector Pa can be used to penalize population on higher energy states but we won't consider that in this example. There are a variety of ways to define the projector Pa. In this example a null operator was chosen because we don't care what evolution the other subspaces experience.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next we define our target unitary operator (effectively a swap operation between states ket0 and ket1). The matrix elements of the unitary outside the computational subspace can be chosen arbitrarily because when computing the objective function they will be projected away by Pc. Here we just modify the identity matrix.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"U_target = Matrix(Id.data) # We begin by initializing a matrix\nU_target[1,1] = 0.0 \nU_target[2,2] = 0.0\nU_target[1,2] = 1.0\nU_target[2,1] = 1.0","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Finally, we define the QOCProblem:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"prob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem. ","category":"page"},{"location":"examples/example2/#Defining-a-reduction-map","page":"Working with QuantumOptics.jl","title":"Defining a reduction map","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"A reduction map defines how the output from the Schrodinger equation (SE) and the GOAT EOMs are manipulated to return the objective function and any associated derivatives. Here we will use an already implemented reduction map that computes a projective SU measure called \"infidelity.\"","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"SE_reduce_map = SE_infidelity_reduce_map \nGOAT_reduce_map = GOAT_infidelity_reduce_map","category":"page"},{"location":"examples/example2/#Specifying-solver-and-optimization-options","page":"Working with QuantumOptics.jl","title":"Specifying solver and optimization options","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"# Define options for DifferentialEquations.jl (see DifferentialEquation docs for info)\nODE_options = (abstol = 1e-9, reltol= 1e-9, alg=Vern9())\n\n# Define the optimizer options from Optim.jl (See Optim.jl docs for info)\noptim_alg = Optim.LBFGS(linesearch=LineSearches.BackTracking()) # A Back-Tracking linesearch\noptim_options = Optim.Options(g_tol=1e-12,\n                            iterations=10,\n                            store_trace=true,\n                            show_trace=true, extended_trace=false, allow_f_increases=false)","category":"page"},{"location":"examples/example2/#Define-the-initial-guess-and-perform-an-optimization","page":"Working with QuantumOptics.jl","title":"Define the initial guess and perform an optimization","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Here we will define our initial guess and specify which parameters are to be optimized, and how parallelization is to proceed:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"p0 = [0.25,ω,0.0] # The initial parameter guesses\nopt_param_inds = [1,2,3] # The parameters of the vector p0 to optimize -- all parameters in this case\nnum_params_per_GOAT = 3 # This parameter specifies how many derivatives are propogated in each GOAT EOMs","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"This num_params_per_GOAT variable specifies how many derivatives are propogated in each GOAT EOMs and informs parallelization. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"For example, if num_params_per_GOAT=5and there are 5 total parameters, then no parallelization is performed. In contrast, if num_params_per_GOAT=2 and there are 5 total parameters, then 3 processes are run in parallel: the first processor computes the EOMs for 2 parameters, the second process computes the EOMs for 2 parameters, and the third computes the EOMs for 1 parameter. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next we put all of these parameters into a QOCParameters struct:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"params = QOCParameters(ODE_options,SE_reduce_map,GOAT_reduce_map,optim_alg,optim_options; num_params_per_GOAT=num_params_per_GOAT)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Finally we run our optimization","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"res = find_optimal_controls(p0, opt_param_inds, sys, prob, params)\nres","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"The converged infidelity should be around 7e-4, higher fidelities are possible. Explore the ansatz, control time, and other parameters to find a better optimum!","category":"page"},{"location":"core/Methods/#Finding-optimal-controls","page":"Finding optimal controls","title":"Finding optimal controls","text":"","category":"section"},{"location":"core/Methods/","page":"Finding optimal controls","title":"Finding optimal controls","text":"Once the primary datastructures have been defined (ControllableSystem, QOCProblem, and QOCParams) we are now in a position to perform the quantum optimal control experiment!! This is done as follows:","category":"page"},{"location":"core/Methods/","page":"Finding optimal controls","title":"Finding optimal controls","text":"sys = ControllableSystem(...)\nprob = QOCProblem(...)\nparams = QOCParams(...)\np0 = [...] # Initial guess\nresult = find_optimal_controls(p0, sys, prob, params)","category":"page"},{"location":"core/Methods/","page":"Finding optimal controls","title":"Finding optimal controls","text":"which will begin the optimization at the initial guess p0 and continue until the stopping criteria is reached. ","category":"page"},{"location":"core/Methods/","page":"Finding optimal controls","title":"Finding optimal controls","text":"This syntax is useful because it allows the user to modify systems, problems, parameters, or initial guesses independently of one another. For example, one could re-define the ControllableSystem using a different ansatz or reference frame and not have to change any other bit of code. This is particularly useful if one is interested in custom control ansatze or objective functions. ","category":"page"},{"location":"examples/example1/#Optimizing-a-gaussian-pulse-for-a-single-qubit","page":"Single qubit control","title":"Optimizing a gaussian pulse for a single qubit","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"This is perhaps the simplest example of a quantum optimal control problem. The physical task is to invert a qubit's population from he ground state ket0 to the orthogonal state ket1.","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Given a qubit Hamiltonian ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"H(t) = fracomega2sigma_z + Omega(t)sigma_x","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"one can determine analytically that there are a family of pulses which will accomplish the control task if the following criteria is met:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"int_0^t dtau Omega(tau) = pi","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"one common choice of Omega(t) is a Gaussian function (due to an array of reasons outside the scope of this example). ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"For this example we will fix the mean and standard deviation of the Gaussian to mu=T2 and sigma = T8. Therefore, we must determine the amplitude of the Gaussian in order to satisfy the topological criteraia and create population inversion.","category":"page"},{"location":"examples/example1/#Imports","page":"Single qubit control","title":"Imports","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"using GOAT\nusing LinearAlgebra, SparseArrays # For instantiating necessary matrices\nusing OrdinaryDiffEq # Load differetial equation algorithms\nusing Optim, LineSearches # Load optimization and linesearch algorithms","category":"page"},{"location":"examples/example1/#Defining-the-ControllableSystem","page":"Single qubit control","title":"Defining the ControllableSystem","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"We begin by defining the necessary operators for the Hamiltonian","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"σx = sparse(ComplexF64[0 1 ; 1  0])# The Pauli X matrix\nσy = sparse(ComplexF64[0 -im ; im 0]) # The Pauli Y matrix\nσz = sparse(ComplexF64[1 0 ; 0 -1]) # The Pauli Z matrix\nσI = sparse(ComplexF64[1 0 ; 0  1]) # The identity matrix","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we define the Hamiltonian parameters and the control basis operators","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"ω = 5*2pi # Setting a qubit frequency\nT = 10.0 # in arbitrary time units\nH0 = (ω/2)*σz # Setting the drift component of the Hamiltonian\nbasis_ops = [σx] # The control basis operator","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we choose a control ansatz specifying only a single basis function","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"N_basis_funcs = 1\nΩ(p,t,i) = gaussian_coefficient(p,t,i,N_basis_funcs)*cos(ω*t) # The control ansatz is a gaussian envelope of a cosine wave at frequency ω\n∂Ω(p,t,i,l) = ∂gaussian_coefficient(p,t,i,l,N_basis_funcs)*cos(ω*t) # The derivative of the control ansatz","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"and specify a rotating frame","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"rotating_frame_generator = -Diagonal(Matrix(H0)) # Moving into the interaction picture","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Finally we are able to specify our ControllableSystem:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"sys = ControllableSystem(H0, basis_ops, rotating_frame_generator, Ω, ∂Ω)","category":"page"},{"location":"examples/example1/#Defining-the-QOCProblem","page":"Single qubit control","title":"Defining the QOCProblem","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"First we define our target unitary operator","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"U_target = deepcopy(σx) # The targt unitary: X|0> = |1>","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Now, we provide a projector onto the computational and ancillary subspaces","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Pc = σI # The projector onto the computational subspace (which is the whole Hilbert space in this case)\nPa = 0.0*Pc # The projector onto the ancillary subspaces (which is a null operator in this case)\nprob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem. ","category":"page"},{"location":"examples/example1/#Defining-a-reduction-map","page":"Single qubit control","title":"Defining a reduction map","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"A reduction map defines how the output from the Schrodinger equation (SE) and the GOAT EOMs are manipulated to return the objective function and any associated derivatives. Here we will use an already implemented reduction map that computes a projective SU measure called \"infidelity.\"","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"SE_reduce_map = SE_infidelity_reduce_map \nGOAT_reduce_map = GOAT_infidelity_reduce_map","category":"page"},{"location":"examples/example1/#Specifying-solver-and-optimization-options","page":"Single qubit control","title":"Specifying solver and optimization options","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"# Define options for DifferentialEquations.jl (see DifferentialEquations.jl docs for info)\nODE_options = (abstol = 1e-9, reltol= 1e-9, alg=Vern9())\n\n# Define the optimizer options from Optim.jl (See Optim.jl docs for info)\noptim_alg = Optim.LBFGS(linesearch=LineSearches.BackTracking()) # A Back-Tracking linesearch\noptim_options = Optim.Options(g_tol=1e-12,\n                            iterations=10,\n                            store_trace=true,\n                            show_trace=true, extended_trace=false, allow_f_increases=false)","category":"page"},{"location":"examples/example1/#Define-the-initial-guess-and-perform-an-optimization","page":"Single qubit control","title":"Define the initial guess and perform an optimization","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Here we will define our initial guess and specify which parameters are to be optimized, and how parallelization is to proceed:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"p0 = [0.5,T/2,T/8] # The initial parameter guesses\nopt_param_inds = [1] # The parameters of the vector p0 to optimize (just the amplitude parameter -- p0[1] -- in this case)\nnum_params_per_GOAT = 1 ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"This num_params_per_GOAT variable specifies how many derivatives are propogated in each GOAT EOMs and informs parallelization. ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"For example, if num_params_per_GOAT=5and there are 5 total parameters, then no parallelization is performed. In contrast, if num_params_per_GOAT=2 and the  re are 5 total parameters, then 3 processes are run in parallel: the first processor computes the EOMs for 2 parameters, the second process computes the EOMs for 2 parameters, and the third computes the EOMs for 1 parameter. ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we put all of these parameters into a QOCParameters struct:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"params = QOCParameters(ODE_options,SE_reduce_map,GOAT_reduce_map,optim_alg,optim_options; num_params_per_GOAT=num_params_per_GOAT)","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Finally we run our optimization","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"res = find_optimal_controls(p0, opt_param_inds, sys, prob, params)\nres","category":"page"},{"location":"core/API_reference/","page":"API Reference","title":"API Reference","text":"Modules = [GOAT]\nOrder   = [:type, :function]","category":"page"},{"location":"core/API_reference/#GOAT.ControllableSystem","page":"API Reference","title":"GOAT.ControllableSystem","text":"Instantiate a ControllableSystem struct.\n\n\n\n\n\n","category":"type"},{"location":"core/API_reference/#GOAT.ControllableSystem-NTuple{4, Any}","page":"API Reference","title":"GOAT.ControllableSystem","text":"ControllableSystem(drift_op, basis_ops, c_func, ∂c_func)\n\nInstantiate a ControllableSystem struct from input operators and functions.\n\nThe basis_ops is a vector of basis operators which will be weighted by the coefficient functions c_func. ∂c_func computes the first derivative of  c_func evaluated at an input.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.ControllableSystem-Tuple{Any, Any, LinearAlgebra.Diagonal, Any, Any}","page":"API Reference","title":"GOAT.ControllableSystem","text":"ControllableSystem(drift_op, basis_ops, RF_generator::Eigen, c_func, ∂c_func; <keyword arguments>)\n\nInstantiate a ControllableSystem struct with a specified RF_generator. \n\nThe RF_generator is a specification of the time-independent generator of the rotating reference frame. i.e., if V(t)=A*V(t) where A is the generator of type LinearAlgebraDiagonal.\n\nKeyword Arguments\n\nsparse_tol::Float: A tolerance which defines a threshold to discard matrix elements\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.ControllableSystem-Tuple{Any, Any, LinearAlgebra.Eigen, Any, Any}","page":"API Reference","title":"GOAT.ControllableSystem","text":"ControllableSystem(drift_op, basis_ops, RF_generator::Eigen, c_func, ∂c_func; <keyword arguments>)\n\nInstantiate a ControllableSystem struct with a specified RF_generator. \n\nThe RF_generator is a specification of the time-independent generator of the rotating reference frame. i.e., if V(t)=A*V(t) where A is the generator of type Eigen.\n\nKeyword Arguments\n\nsparse_tol::Float: A tolerance which defines a threshold to discard matrix elements\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.ControllableSystem-Tuple{Any, Any, Matrix, Any, Any}","page":"API Reference","title":"GOAT.ControllableSystem","text":"ControllableSystem(drift_op, basis_ops, RF_generator::Matrix, c_func, ∂c_func; <keyword arguments>)\n\nInstantiate a ControllableSystem struct with a specified RF_generator. \n\nThe RF_generator is a specification of the time-independent generator of the rotating reference frame. i.e., if V(t)=A*V(t) where A is the generator of type Matrix.\n\nKeyword Arguments\n\nsparse_tol::Float: A tolerance which defines a threshold to discard matrix elements\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.QOCParameters","page":"API Reference","title":"GOAT.QOCParameters","text":"Instantiate a QOCParameters struct.\n\n\n\n\n\n","category":"type"},{"location":"core/API_reference/#GOAT.QOCParameters-NTuple{5, Any}","page":"API Reference","title":"GOAT.QOCParameters","text":"QOCParameters(ODE_options,SE_reduce_map, GOAT_reduce_map, optim_alg, optim_options; <keyword arguments> )\n\nInstantiate a QOCParameters struct with specified parameters. \n\nArguments\n\nODE_options::NamedTuple: The settings that will be input to the ODE solver.\nSE_reduce_map::Function: A function mapping the output from the Schrodinger equation to the objective value.\nGOAT_reduce_map::Function: A function mapping the output from the GOAT E.O.M.s to the objective value and gradient.\noptim_alg::Optim Algorithm: The specific optimization algorithm specified via Optim.jl\noptim_options::Optim options: The optimization algorithm options specified via Optim.jl\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.QOCProblem","page":"API Reference","title":"GOAT.QOCProblem","text":"Instantiate a QOCProblem struct.\n\n\n\n\n\n","category":"type"},{"location":"core/API_reference/#GOAT.QOCProblem-NTuple{4, Any}","page":"API Reference","title":"GOAT.QOCProblem","text":"QOCProblem(target, control_time, Pc, Pa)\n\nInstantiate a QOCProblem struct with specified input operators and control time.\n\nArguments\n\ntarget::Array{ComplexF64}: the target unitary operator in the computational subspace.\ncontrol_time::Float64: The duration of the control.\nPc::Array{ComplexF64}: A projector from the full unitary operator on the system to the computational subspace\nPa::Array{ComplexF64}: A projector from the full unitary operator on the system to any ancillary subspace\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.GOAT_action!-Tuple{Array{ComplexF64}, Array{ComplexF64}, Vector{Float64}, Float64, Vector{Int64}, Vector{Int64}, Vector{ComplexF64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{ComplexF64}}, Vector{Int64}, Function, Function}","page":"API Reference","title":"GOAT.GOAT_action!","text":"GOAT_action!(du, u, p, t, d_ms, d_ls, d_vs, c_ms, c_ls, c_vs, opt_param_inds, c_func, ∂c_func)\n\nCompute the action of the GOAT equation of motions on a matrix u and place in du.\n\nArguments\n\ndu::Array{ComplexF64}: The array for the derivative t\nu::Array{ComplexF64}: The array for the state at time t\np::Vector{Float64}: The parameter vector defining the evolution. \nt::Float64: The time.\nd_ms::Vector{Vector{Int64}}: The sparse representation of the drift operator's first index.\nd_ls::Vector{Vector{Int64}}: The sparse representation of the drift operators's second index.\nd_vs::Vector{Vector{ComplexF64}}: The sparse representation of the mtrix element of the drift operator.\nc_ms::Vector{Vector{Int64}}: The sparse representation of the control operators' first index.\nc_ls::Vector{Vector{Int64}}: The sparse representation of the control operators' second index.\nc_vs::Vector{Vector{ComplexF64}}: The sparse representation of the mtrix element of the control operators.\nopt_param_inds::Vector{Int64}: The indices of the parameter vector p to propogate a derivative for\nc_func::Function: The function that computes the time-dependent coefficients of the control operators.\n∂c_func::Function: The function that computes the derivative of the time-dependent coefficients of the control operators.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.GOAT_infidelity_reduce_map-Tuple{ControllableSystem, QOCProblem, Any}","page":"API Reference","title":"GOAT.GOAT_infidelity_reduce_map","text":"GOAT_infidelity_reduce_map(sys, prob, goat_sol)\n\nMaps the GOAT ODE solution to the objective function and gradient vector using an infidelity measure.\n\nArguments\n\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The QOCProblem\ngoat_sol::OrdinaryDiffEq.solution: The solution to the GOAT equations of motion.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.L1-Tuple{Any, Any, Any}","page":"API Reference","title":"GOAT.L1","text":"L1(U, P1, P2)\n\nComputes the instantaneous population transferred from between two subspaces.\n\nP1 and P2 are projectors onto subspaces 1 and 2.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.LO-Tuple{Any, Any}","page":"API Reference","title":"GOAT.LO","text":"LO(t,w)\n\nSimulates a local oscillator with frequency w.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.NoDiffControllableSystem-Tuple{Any, Any, Any}","page":"API Reference","title":"GOAT.NoDiffControllableSystem","text":"NoDiffControllableSystem(drift_op, basis_ops, c_func)\n\nInstantiate a ControllableSystem struct with no specified ∂c_func.\n\nThe basis_ops is a vector of basis operators which will be weighted by the coefficient functions c_func.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.S-Tuple{Any, Any, Any}","page":"API Reference","title":"GOAT.S","text":"S(x, lower, upper ; gradient=1)\n\nA saturation function that limits amplitudes to a particular range specified by [lower,upper].\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.SE_action!-Tuple{Array{ComplexF64}, Array{ComplexF64}, Vector{Float64}, Float64, Vector{Int64}, Vector{Int64}, Vector{ComplexF64}, Vector{Vector{Int64}}, Vector{Vector{Int64}}, Vector{Vector{ComplexF64}}, Function}","page":"API Reference","title":"GOAT.SE_action!","text":"SE_action!(du, u, p, t, d_ms, d_ls, d_vs, c_ms, c_ls, c_vs, c_func)\n\nCompute the action of the Schrodinger equation on a matrix u and place in du.\n\nArguments\n\ndu::Array{ComplexF64}: The array for the derivative t\nu::Array{ComplexF64}: The array for the state at time t\np::Vector{Float64}: The parameter vector defining the evolution. \nt::Float64: The time.\nd_ms::Vector{Vector{Int64}}: The sparse representation of the drift operator's first index.\nd_ls::Vector{Vector{Int64}}: The sparse representation of the drift operators's second index.\nd_vs::Vector{Vector{ComplexF64}}: The sparse representation of the mtrix element of the drift operator.\nc_ms::Vector{Vector{Int64}}: The sparse representation of the control operators' first index.\nc_ls::Vector{Vector{Int64}}: The sparse representation of the control operators' second index.\nc_vs::Vector{Vector{ComplexF64}}: The sparse representation of the mtrix element of the control operators.\nc_func::Function: The function that computes the time-dependent coefficients of the control operators.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.SE_infidelity_reduce_map-Tuple{ControllableSystem, QOCProblem, Any}","page":"API Reference","title":"GOAT.SE_infidelity_reduce_map","text":"SE_infidelity_reduce_map(sys, prob, SE_sol)\n\nMaps Schrodinger ODE solution to the objective function using an infidelity measure.\n\nArguments\n\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The QOCProblem\nSE_sol::OrdinaryDiffEq.solution: The solution to the Schrodinger equation.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.colored_noise-Tuple{Float64, Float64, Int64, Float64, Int64}","page":"API Reference","title":"GOAT.colored_noise","text":"colored_noise(lf, hf, n, alpha, seed)\n\nGenerate a set of amplitude, frequencies, and phases for randomly generated colored noise. \n\nSpecifically, generates colored noise with P(ω) ∝ ωᵅ\n\nArguments\n\nlf: The low frequency cutoff. \nhf: The high frequency cutoff.\nn: The number of frequncy components.\nalpha: The color of the noise.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.dSdx-Tuple{Any, Any, Any}","page":"API Reference","title":"GOAT.dSdx","text":"dSdx(x, lower, upper; gradient=1)\n\nCalculates the partial derivative of the saturation function w.r.t the independent variable x.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.evaluate_objective-Tuple{Vector{Float64}, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.evaluate_objective","text":"evaluate_objective(p, sys, prob, params)\n\nEvaluate the objective function at p.\n\nArguments:\n\np: The optimal control parameters at which to evalute the objective. \nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The quantum optimal control problem.\nparam::QOCParameters: The quantum optimal control parameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.evaluate_objective-Tuple{Vector{Vector{Float64}}, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.evaluate_objective","text":"evaluate_objective(ps, sys, prob, params)\n\nParallelized evaluation the objective function at multiple control parameters.\n\nArguments:\n\nps::Vector{Vector{Float64}}: The optimal control parameters at which to evalute the objective. \nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The quantum optimal control problem.\nparam::QOCParameters: The quantum optimal control parameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.find_optimal_controls-Tuple{Any, Any, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.find_optimal_controls","text":"find_optimal_controls(p0, opt_param_inds, sys, prob, params)\n\nRun the GOAT algorithm and find optimal controls.\n\nArguments:\n\np0: The initial guess of the optimal control parameters.\nopt_param_inds: Indices of p0 which specify which parameters to hold constant and which to optimize.\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The quantum optimal control problem.\nparam::QOCParameters: The quantum optimal control parameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.find_optimal_controls-Tuple{Any, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.find_optimal_controls","text":"find_optimal_controls(p0, sys, prob, params)\n\nRun the GOAT algorithm and find optimal controls.\n\nArguments:\n\np0: The initial guess of the optimal control parameters.\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The quantum optimal control problem.\nparam::QOCParameters: The quantum optimal control parameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.flat_top_cosine-NTuple{4, Any}","page":"API Reference","title":"GOAT.flat_top_cosine","text":"flat_top_cosine(t, A, T, tr)\n\nA flat-top cosine function kernel. \n\nArguments\n\nA: The amplitude of the function.\nT: Duration of the function.\ntr: The rise and fall time.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.fourier_coefficient-Tuple{Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.fourier_coefficient","text":"fourier_coefficient(p,t,i,N)\n\nCompute the time dependent coefficient for a control basis operator given by a Fourier ansatze.\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.g_abs-Tuple{Any, Any}","page":"API Reference","title":"GOAT.g_abs","text":"g_abs(V, U)\n\nComputes the norm of the difference between V and U.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.g_real-Tuple{Any, Any}","page":"API Reference","title":"GOAT.g_real","text":"g_real(V, ∂U)\n\nComputes infidelity based on the real component of the overlap between V and U.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.g_sm-Tuple{Any, Any}","page":"API Reference","title":"GOAT.g_sm","text":"g_sm(V, ∂U)\n\nComputes infidelity via the squared modulus of the overlap between V and U.\n\nThis definition is perhaps the most standard used for quantum optimal control of unitaries.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.gaussian_coefficient-Tuple{Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.gaussian_coefficient","text":"gaussian_coefficient(p,t,i,N)\n\nCompute the time dependent coefficient for a control basis operator given by a gaussian ansatze.\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.gaussian_kernel-NTuple{4, Any}","page":"API Reference","title":"GOAT.gaussian_kernel","text":"gaussian_kernel(t, a, mu,sigma)\n\nComputes the value of a gaussian. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.general_logistic","page":"API Reference","title":"GOAT.general_logistic","text":"general_logistic(t, lower, upper, slope, start, nu)\n\nA version of a generalized logistic function found on wikipedia:  https://en.wikipedia.org/wiki/Generalisedlogisticfunction.\n\nArguments\n\nt: The time.\nlower: The lower asymptote.\nupper: The upper asymptote.\nslope : The slope of the function.\nstart = 1e3: A shift of the logistic function to adjust general_logistic(t=0).\nnu = 1.0: A parameter to set where the maximum derivative is located. \n\n\n\n\n\n","category":"function"},{"location":"core/API_reference/#GOAT.get_sinusoidal_basis_parameters-Tuple{Any, Any}","page":"API Reference","title":"GOAT.get_sinusoidal_basis_parameters","text":"get_sinusoidal_basis_parameters(ts, s)\n\nCompute the sinusoidal amplitude, frequencies, and phases of a signal.\n\nOutputs a triplet of: Amps, freqs, phases via the decomposition: s(t) = ᵢ aᵢ sin(ωᵢt+ϕᵢ).\n\nArguments\n\nts: the sampling times\ns: the signal at each sampling time\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.h_sm-NTuple{4, Any}","page":"API Reference","title":"GOAT.h_sm","text":"h_sm(Us,Pc,Pd,ts)\n\nComputes the total population transferred from between two subspaces during the control time. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.make_GOAT_initial_state-Tuple{Any, Any}","page":"API Reference","title":"GOAT.make_GOAT_initial_state","text":"make_GOAT_initial_state(d,opt_param_inds)\n\nGenerate the initial state of the coupled equations of motion for the GOAT method. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.make_GOAT_update_function-Tuple{ControllableSystem, Vector{Int64}}","page":"API Reference","title":"GOAT.make_GOAT_update_function","text":"make_GOAT_update_function(sys,opt_param_inds)\n\nGenerate an in-place update function f!(du,u,p,t) for the GOAT equations of motion equation.\n\nArguments\n\nsys::ControllableSystem: The controllable system.\nopt_param_inds::Vector{Int64}: A vector of indices that specifies which control derivatives will be propogated.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.make_SE_update_function-Tuple{ControllableSystem}","page":"API Reference","title":"GOAT.make_SE_update_function","text":"make_SE_update_function(sys)\n\nGenerate an in-place update function f!(du,u,p,t) for the Schrodinger equation based on sys.\n\nArguments\n\nsys::ControllableSystem: The controllable system \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.morlet_kernel-NTuple{6, Any}","page":"API Reference","title":"GOAT.morlet_kernel","text":"morlet_kernel(t, a, mu, sigma, w, phi)\n\nMorlet wavelet kernel (although not a true wavelet because it is not normalized).\n\nEffectively a gaussian-windowed sinusoid function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.parallel_GOAT_fg!-Tuple{Any, Any, Any, Any, Any, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.parallel_GOAT_fg!","text":"parallel_GOAT_fg!(F, G, p, p_storage, opt_param_inds, sys, prob, params)\n\nParallelized computation of the objective and gradient for QOC with GOAT.\n\nArguments\n\nF: The objective value\nG: The vector of gradients w.r.t. the control parameters p. \np: The control parameter vector.\np_storage: A pre-allocated storage vector for current p values. \nopt_param_inds: The vector of parameter indices which determines which gradients are calculated.\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The QOCProblem\nparam::QOCParameters: The QOCParameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.parallel_GOAT_fg!-Tuple{Any, Any, Any, ControllableSystem, QOCProblem, QOCParameters}","page":"API Reference","title":"GOAT.parallel_GOAT_fg!","text":"parallel_GOAT_fg!(F, G, p, sys, prob, params)\n\nParallelized computation of the objective and gradient for QOC with GOAT.\n\nArguments\n\nF: The objective value\nG: The vector of gradients w.r.t. the control parameters p. \np: The control parameter vector.\nsys::ControllableSystem: The controllable system.\nprob::QOCProblem: The QOCProblem\nparam::QOCParameters: The QOCParameters.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.poly_coefficient-Tuple{Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.poly_coefficient","text":"poly_coefficient(p,t,i,N)\n\nCompute the time dependent coefficient for a control basis operator given by a polynomial ansatze.\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.sinusoid_kernel-NTuple{4, Any}","page":"API Reference","title":"GOAT.sinusoid_kernel","text":"sinusoid_kernel(t, a, w, phi)\n\nComputes the value of a sine function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.solve_GOAT_eoms-Tuple{ControllableSystem, Vector{Int64}, Float64, Vector{Float64}}","page":"API Reference","title":"GOAT.solve_GOAT_eoms","text":"solve_GOAT_eoms(sys, opt_param_inds, Tmax, p; <keyword arguments>)\n\nIntegrate the Schrodinger equation for a specified time and control parameter set. \n\nArguments\n\nsys::ControllableSystem: The controllable system.\nopt_param_inds::Vector{Int64}: The vector of parameter indices specifying which gradients will be propogated.\nTmax::Float64: The total contorl time.\np::Vector{Float64}: The parameters which define the controlled evolution.\nODE_options: The specification of the integrator settings from OrdinaryDiffEq.jl\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.solve_GOAT_eoms_reduce-Tuple{Any, ControllableSystem, QOCProblem, Any, QOCParameters}","page":"API Reference","title":"GOAT.solve_GOAT_eoms_reduce","text":"solve_GOAT_eoms_reduce(p, sys, prob, opt_param_inds, params::QOCParameters)\n\nSolves the GOAT eoms and outputs a objective function and gradient vector.\n\nArguments\n\np: The control parameter vector at which the objective and gradient is being calculated. \nsys::ControllableSystem: The controllable system.\nopt_param_inds: The vector of parameter indices which determines which gradients are calculated.\nparam::QOCParameters: The QOCParameters which provides the ODE_options.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.solve_SE-Tuple{ControllableSystem, Float64, Vector{Float64}}","page":"API Reference","title":"GOAT.solve_SE","text":"solve_SE(sys, Tmax, p; <keyword arguments>)\n\nIntegrate the Schrodinger equation for a specified time and control parameter set. \n\nArguments\n\nsys::ControllableSystem: The controllable system.\nTmax::Float64: The total contorl time.\np::Vector{Float64}: The parameters which define the controlled evolution.\nODE_options: The specification of the integrator settings from OrdinaryDiffEq.jl\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.test_derivatives-NTuple{5, Any}","page":"API Reference","title":"GOAT.test_derivatives","text":"test_derivatives(sys, prob, params, opt_param_inds, p_test; <keyword arguments>)\n\nUses a finite difference method to confirm that gradients are calculated correctly.\n\nIf only_coefficeint_funcs=true then only the coefficient functions are checked. If only_coefficeint_funcs=false then the GOAT equations of motion  are solved and unitary gradients are checked too. \n\nArguments\n\nsys: The ControllableSystem.\nprob: The QOCProblem.\nparams: The QOCParameters.\ndh=1e-8: The finite-difference step size of each parameter.\ntol=1e-5: The tolerance that determines whether an error is raised. \nonly_coefficeint_funcs=true: Specifies if checking gradients of coefficients or unitaries. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.time_domain_signal-Tuple{Float64, Any, Any, Any, Any}","page":"API Reference","title":"GOAT.time_domain_signal","text":"time_domain_signal(t::Float64, amps, freqs, phases, N)\n\nCompute a truncated inverse fourier transform at time t.\n\nThe signal s(t) is reconstructed via the function s(t) = ᵢ aᵢ cos(ωᵢt+ϕᵢ)\n\nArguments\n\nt: The time to evaluate the inverse FFT.\namps: The amplitudes.\nfreqs: The frequencies.\nphases: The phases.\nN: The number of components to keep when reconstructing the signal.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.time_domain_signal-Tuple{Float64, Any, Any, Any}","page":"API Reference","title":"GOAT.time_domain_signal","text":"time_domain_signal(t::Float64, amps, freqs, phases)\n\nCompute a truncated inverse fourier transform at time t.\n\nThe signal s(t) is reconstructed via the function s(t) = ᵢ aᵢ sin(ωᵢt+ϕᵢ)\n\nArguments\n\nt: The time to evaluate the inverse FFT.\nAks: The amplitudes.\nfreqs: The frequencies.\nphi_ks: The phases.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.window","page":"API Reference","title":"GOAT.window","text":"window(x,lower,upper,gradient)\n\nA windowing function based on a product of two generalized logistic functions.\n\nSee general_logistic for additional details.\n\nArguments\n\nlower: The location of the left tail.\nright: The location of the right tail.\ngradient: The maximum gradient of the logistic functions\n\n\n\n\n\n","category":"function"},{"location":"core/API_reference/#GOAT.∂fourier_coefficient-Tuple{Any, Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.∂fourier_coefficient","text":"∂fourier_coefficient(p,t,i,l,N)\n\nComputes the partial derivative of fourier_coefficient w.r.t p[l] evaluated at (p,t).\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nl: The index of the p with which to compute the partial derivative to. \nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂g_abs-Tuple{Any, Any}","page":"API Reference","title":"GOAT.∂g_abs","text":"∂g_abs(V, ∂U)\n\nComputes the partial derivative of g_abs w.r.t U evaluated at ∂U\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂g_real-Tuple{Any, Any}","page":"API Reference","title":"GOAT.∂g_real","text":"∂g_real(V, ∂U)\n\nComputes the partial derivative of g_real w.r.t U evaluated at ∂U.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂g_sm-Tuple{Any, Any, Any}","page":"API Reference","title":"GOAT.∂g_sm","text":"∂g_sm(V, ∂U)\n\nComputes the partial derivative of g_sm w.r.t U evaluated at ∂U.\n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂gaussian_coefficient-Tuple{Any, Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.∂gaussian_coefficient","text":"∂gaussian_coefficient(p,t,i,l,N::Int64)\n\nComputes the partial derivative of fourier_coefficient w.r.t p[l] evaluated at (p,t).\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nl: The index of the p with which to compute the partial derivative to. \nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂h_sm-NTuple{5, Any}","page":"API Reference","title":"GOAT.∂h_sm","text":"∂h_sm(Us,∂Us,I1,I2,ts)\n\nComputes the partial derivative of h_sm w.r.t. U evaluated at ∂U \n\n\n\n\n\n","category":"method"},{"location":"core/API_reference/#GOAT.∂poly_coefficient-Tuple{Any, Any, Any, Any, Int64}","page":"API Reference","title":"GOAT.∂poly_coefficient","text":"∂poly_coefficient(p,t,i,l,N)\n\nComputes the partial derivative of fourier_coefficient w.r.t p[l] evaluated at (p,t).\n\nArguments\n\np: The vector of control parameters.\nt: The time at which to evaluate the coefficient function.\ni: The index of the control basis operator.\nl: The index of the p with which to compute the partial derivative to. \nN: The total number of basis functions used to define the coefficient function. \n\n\n\n\n\n","category":"method"},{"location":"recommendations/#Recommendations-and-notes","page":"Recommendations","title":"Recommendations and notes","text":"","category":"section"},{"location":"recommendations/","page":"Recommendations","title":"Recommendations","text":"While not a direct dependency, the authors recommend using the QuantumOptics.jl to model the details of the quantum system (vectors/operators used in the computation). At the moment, GOAT.jl does not have methods that accept operator types from QuantumOptics.jl, but we do plan to add this functionality in the future. ","category":"page"},{"location":"#GOAT.jl-–-Gradient-Optimization-of-Analytic-Controls-in-Julia","page":"Home","title":"GOAT.jl – Gradient Optimization of Analytic Controls in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is a Julia implementation of the Gradient Optimization of Analytic conTrols (GOAT) optimal control methodology proposed in this paper by Machnes et al.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation only currently supports computing unitary evolution. Please peruse through the documentation and examples.","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please use the following citation for referencing this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"TBD","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this work is supported by the U.S. Department of Energy Office of Science (DOE-SC) Office of Advanced Scientific Computing Research (ASCR) Advancing Integrated Development Environments for Quantum Computing through Fundamental Research (AIDE-QC) project under contract number DE-AC02-06CH11357.","category":"page"},{"location":"core/Ansatz/#Control-Ansatze","page":"Control Ansatze","title":"Control Ansatze","text":"","category":"section"},{"location":"core/Ansatz/#Defintion-and-syntax","page":"Control Ansatze","title":"Defintion and syntax","text":"","category":"section"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"The GOAT algorithm assumes that the each control function is described as a combination of a set of parametrized basis functions. Referred to as an ansatz (plural: ansatze), the choice of decomposition is typically informed by experimental considerations. GOAT.jl allows the user to specify arbitrary control ansatze and build complex ansatze that include window functions, saturation functions, filters, etc. ","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"Recall that we define the Hamiltonian as:","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"H(vecalphat)  = H_0 + sum_i c_i(vecalphat) H_i","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"The coefficient functions c_i(vecalphat) in GOAT.jl are a function of all the control parameters vecalpha, but only weight the control basis operator H_i. This is a mathematically general definition and any Hamiltonian can be specified in this way. However, it is common to see control functions that only depend on a small set of parameters.","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"From an interface point of view, the coefficient function must be defined as follows:","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"function c(p,t,i,N)\n    ...\n    return c\nend","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"where p is the vector of parameters, t is the time, i defines which control operator H_i it is associated with, and N indicates the number of basis functions used. One must also define the derivative in order to perform gradient-based optimization: ","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"function ∂c(p,t,i,l,N)\n    ...\n    return c\nend","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"where l is the index that specifies which parameter p[l] that the differentiation is being performed about: ∂c(p,t,i,l,N) = partial c partial p_l _t. ","category":"page"},{"location":"core/Ansatz/#Examples","page":"Control Ansatze","title":"Examples","text":"","category":"section"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"Check out the examples to see how one can define custom ansatze and derivatives using the chain rule. ","category":"page"},{"location":"core/Ansatz/#Included-basis-functions","page":"Control Ansatze","title":"Included basis functions","text":"","category":"section"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"Included in this package are a number of common function decompositions for a Fourier basis, Gaussian basis, and polynomial basis:","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"Modules = [GOAT]\nPages = [\"Ansatze.jl\"]\nOrder   = [:function]","category":"page"},{"location":"core/Ansatz/#Utility-functions","page":"Control Ansatze","title":"Utility functions","text":"","category":"section"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"We also include a number of utility functions that can be used when defining custom ansatze:","category":"page"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"Modules = [GOAT]\nPages = [\"Utilities.jl\"]\nOrder = [:function]","category":"page"},{"location":"core/ReferenceFrames/#Reference-frames","page":"Reference frames","title":"Reference frames","text":"","category":"section"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"Within this package we also provide the support to define dynamical reference frames. A choice of reference frame (sometimes called an \"rotating frame\" or an \"interaction picture\") is a mathematical and physical utility used to simplify quantum dynamics. In general a reference frame is provided by a time-dependent unitary operator V(t). If the unitary is time-independent then the reference frame coincides with a change of basis, thus one can think of a dynamical reference frame as a time-dependent choice of basis functions. ","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"With a time-dependent unitary operator V(t) defined, one derives a new effective Hamiltonian within the reference frame using the systems Hamiltonian H(t) and the Schrodinger equation:","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"beginalign*\n    ihbar partial_t biggV(t)ketpsi(t)bigg = ihbar bigg (partial_t V(t))ketpsi(t) + V(t) partial_tketpsi(t) bigg \n    = ihbar bigg (partial_t V(t)) + V(t) frac1i hbar H(t) bigg ketpsi(t) \n    = ihbar bigg (partial_t V(t)) V^dagger(t) + frac1i hbar V(t)H(t)V^dagger(t) bigg V(t)ketpsi(t) \n    = H_eff(t) bigg V(t) ketpsi(t) bigg\nendalign*","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"While the reference frame is defined as a unitary operator, it is often more compact to specify the reference frame by specifying the generator of the unitary. In other words specify a Hermitian operator A such that V(t) = exp-fracithbar A. This operator may be derived from the system's Hamiltonian and is often chosen in such a way that the effective quantum dynamics within the reference frame is simplified. The most common example taught in contemporary quantum mechanics is known as the interaction picture. ","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"However, the interaction picture is only a particular choice of refence frame! Many other references frames can be defined which are esspecially interesting or useful (See for example, the original DRAG paper where a time-dependent reference frame is used to derive some of the most effective and common control pulses used today.)","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"Reference frames are particularly important in experimental quantum devices! One example of this is occurs in assessing the \"idling\" error. Idling error occurs when coherent quantum dynamics occur even when the system is not being controlled, i.e. there is a component of the Hamiltonian that is non-zero at every time. This leads to decoherence and errors. A reference frame can be chosen to mininimize these unwanted errors. Thus, all controls need to be chosen such that they generate the desired evolutions within the specified reference frame. ","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"For example, in experimental systems local clocks are used to \"lock\" a reference frame and synchronize classical electronics. If there is noise in the clock this appears as noise within the quantum dynamics and can affect quantum device performance (See this paper). ","category":"page"},{"location":"core/ReferenceFrames/","page":"Reference frames","title":"Reference frames","text":"GOAT.jl permits a definition of the generator A and will efficiently compute the quantum dynamics in the rotating frame. How to specify this operator in your simulations is described further in the documentation and the examples.","category":"page"}]
}
