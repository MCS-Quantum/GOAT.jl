var documenterSearchIndex = {"docs":
[{"location":"core/DataStructures/#Details-on-the-ControllableSystem-Struct","page":"Details on the ControllableSystem Struct","title":"Details on the ControllableSystem Struct","text":"","category":"section"},{"location":"core/DataStructures/","page":"Details on the ControllableSystem Struct","title":"Details on the ControllableSystem Struct","text":"something","category":"page"},{"location":"background/Reference_frames/#Reference-frames","page":"Reference frames","title":"Reference frames","text":"","category":"section"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"Within this package we also provide the support to define dynamical reference frames. A choice of reference frame (sometimes called an \"rotating frame\" or an \"interaction picture\") is a mathematical and physical utility used to simplify quantum dynamics. In general a reference frame is provided by a time-dependent unitary operator V(t). If the unitary is time-independent then the reference frame coincides with a change of basis, thus one can think of a dynamical reference frame as a time-dependent choice of basis functions. ","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"With a time-dependent unitary operator V(t) defined, one derives a new effective Hamiltonian within the reference frame using the systems Hamiltonian H(t) and the Schrodinger equation:","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"beginalign*\n    ihbar partial_t biggV(t)ketpsi(t)bigg = ihbar bigg (partial_t V(t))ketpsi(t) + V(t) partial_tketpsi(t) bigg \n    = ihbar bigg (partial_t V(t)) + V(t) frac1i hbar H(t) bigg ketpsi(t) \n    = ihbar bigg (partial_t V(t)) V^dagger(t) + frac1i hbar V(t)H(t)V^dagger(t) bigg V(t)ketpsi(t) \n    = H_eff(t) bigg V(t) ketpsi(t) bigg\nendalign*","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"While the reference frame is defined as a unitary operator, it is often more compact to specify the reference frame by specifying the generator of the unitary. In other words specify a Hermitian operator A such that V(t) = exp-fracithbar A. This operator may be derived from the system's Hamiltonian and is often chosen in such a way that the effective quantum dynamics within the reference frame is simplified. The most common example taught in contemporary quantum mechanics is known as the interaction picture. ","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"However, the interaction picture is only a particular choice of refence frame! Many other references frames can be defined which are esspecially interesting or useful (See for example, the original DRAG paper where a time-dependent reference frame is used to derive some of the most effective and common control pulses used today.)","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"Reference frames are particularly important in experimental quantum devices! One example of this is occurs in assessing the \"idling\" error. Idling error occurs when coherent quantum dynamics occur even when the system is not being controlled, i.e. there is a component of the Hamiltonian that is non-zero at every time. This leads to decoherence and errors. A reference frame can be chosen to mininimize these unwanted errors. Thus, all controls need to be chosen such that they generate the desired evolutions within the specified reference frame. ","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"For example, in experimental systems local clocks are used to \"lock\" a reference frame and synchronize classical electronics. If there is noise in the clock this appears as noise within the quantum dynamics and can affect quantum device performance (See this paper). ","category":"page"},{"location":"background/Reference_frames/","page":"Reference frames","title":"Reference frames","text":"GOAT.jl permits a definition of the generator A and will efficiently compute the quantum dynamics in the rotating frame. How to specify this operator in your simulations is described further in the documentation and the examples.","category":"page"},{"location":"examples/example2/#Optimizing-a-custom-pulse-ansatz-for-a-transmon-using-QuantumOptics.jl","page":"Working with QuantumOptics.jl","title":"Optimizing a custom pulse-ansatz for a transmon using QuantumOptics.jl","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example we will utilize QuantumOptics.jl to define a more complex quantum system – a Duffing oscillator (a good model of a Transmon). We will also define a custom pulse ansatz using some of the pre-defined basis functions in GOAT.jl.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"The quantum systems that people deal with in a laboratory are very often not qubits. Instead, one defines a qubit subspace within the quanutm system you have access to. For example, a duffing oscillator has the Hamiltonian:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H = omega hatn+fracdelta2 hatn(hatn-1)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"where the frequency of the oscillator is specified by omega and delta defines the anharmonicity (it adds a perturbation that makes different energy levels of the oscillator have different transition frequencies). ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"This system has an infinite number of eigenstates that form a ladder-like structure. However, we can define a \"qubit\" within a 2-dimensional subspace. For instance, we can choose the subspace spanned by the two lowest energy eigenstates: 0 rangle 1rangle . ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example, we will use GOAT.jl to find a optimal control that implements a pi rotation within this subspace (i.e, find a unitary V s.t. V0rangle propto 1rangle and V1rangle propto 0rangle). This is a much more challenging task than the one explored in Example 1. In particular, we must make sure that the unitary V does not connect (or minimially connects) the 0rangle or 1rangle states to any other states of the oscillator. This is a process called leakage. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Our control term has the form ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H_c(t) = Omega(t)(hata + hata^dagger) ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Where hata and hata^dagger are the excitation anhilation and creation operators, respectively. ","category":"page"},{"location":"examples/example2/#Imports","page":"Working with QuantumOptics.jl","title":"Imports","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"using GOAT\nusing QuantumOptics\nusing LinearAlgebra, SparseArrays # For instantiating necessary matrices\nusing OrdinaryDiffEq # Load differetial equation algorithms\nusing Optim, LineSearches # Load optimization and linesearch algorithms","category":"page"},{"location":"examples/example2/#Defining-the-ControllableSystem-using-QuantumOptics.jl","page":"Working with QuantumOptics.jl","title":"Defining the ControllableSystem using QuantumOptics.jl","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We first define a Hilbert space using QuantumOptics and then the operators that live on that space:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"b = FockBasis(3) # A Hilbert space basis using a particle-number cutoff of 3 : span(|0⟩, |1⟩, |2⟩, |3⟩)\na = destroy(b) # The particle anhilation operator\nat = create(b) # The particle creation operator\nn = number(b) # The particle number operator\nId = identityoperator(b) # The identity operator","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next, we define the Hamiltonian parameters","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"ω = 5*2pi # Setting a oscillator frequency\nδ = -0.2*2pi # Setting the oscillator anharmonicity \nT = 20.0 # in arbitrary time units","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"And finally the Hamiltonian and the control basis operators. (we access the underlying matrix of the QuantumOptics operator using \".data\" attribute)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"H0 = (ω*n+ 0.5*δ*n*(n-Id)).data # Setting the drift component of the Hamiltonian \nHc = (a+at).data\nbasis_ops = [Hc] # The operators which define the control basis","category":"page"},{"location":"examples/example2/#Defining-a-custom-ansatz","page":"Working with QuantumOptics.jl","title":"Defining a custom ansatz","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We will now define a custom pulse ansatz consisting of a sum of sinusoid functions that are modulated with an envelope function that is a flat-topped-cosine. Each ansatz has a different number of parameters for each basis function. For the Fourier basis the parameters are the amplitude, frequency, and phase of each sinusoid. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"N = 1 # The number of basis functions to use to describe the control. \nfunction Ω(p,t,i)\n    envelope = flat_top_cosine(t,1,T,0.3*T) # A flat-top cosine envelope for our pulse\n    c = fourier_coefficient(p,t,i,N) # The control ansatz is a sum of sinusoidal basis functions\n    return c*envelope\nend\n    \nfunction ∂Ω(p,t,i,l)\n    envelope = flat_top_cosine(t,1,T,0.3*T) # A flat-top cosine envelope for our pulse\n    ∂c = ∂fourier_coefficient(p,t,i,l,N) # The derivative of the control ansatz\n    return ∂c*envelope\nend","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"We now define the reference frame in which we will implement a desired unitary operator:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"rotating_frame_generator = -Diagonal(Matrix(H0)) # Moving into the reference frame rotating at the oscillator frequencies","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"And finally we define the ControllableSystem:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"sys = ControllableSystem(H0, basis_ops, rotating_frame_generator, Ω, ∂Ω)","category":"page"},{"location":"examples/example2/#Defining-the-QOCProblem","page":"Working with QuantumOptics.jl","title":"Defining the QOCProblem","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"In this example, we wish to generate a unitary operator within a subspace of the system's Hilbert space. This requires that the global unitary operator (which is what we compute by solving the Schrodinger Equation and GOAT EOMs) be block-diagonal with respect to a bipartion of the Hilbert space. We reinforce this constrating by specifying the projectors onto the computational and ancillary subspaces. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Pc = (projector(fockstate(b,0))+projector(fockstate(b,1))).data # The projector onto the computational subspace \n# (which is the first two energy levels in this case: |0⟩, |1⟩)\nPa = 0.0*Id.data # The projector onto the ancillary subspaces (which is a null operator in this case)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"the projector Pa can be used to penalize population on higher energy states but we won't consider that in this example. There are a variety of ways to define the projector Pa. In this example a null operator was chosen because we don't care what evolution the other subspaces experience.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next we define our target unitary operator (effectively a swap operation between states ket0 and ket1). The matrix elements of the unitary outside the computational subspace can be chosen arbitrarily because when computing the objective function they will be projected away by Pc. Here we just modify the identity matrix.","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"U_target = Matrix(Id.data) # We begin by initializing a matrix\nU_target[1,1] = 0.0 \nU_target[2,2] = 0.0\nU_target[1,2] = 1.0\nU_target[2,1] = 1.0","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Finally, we define the QOCProblem:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"prob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem. ","category":"page"},{"location":"examples/example2/#Defining-a-reduction-map","page":"Working with QuantumOptics.jl","title":"Defining a reduction map","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"A reduction map defines how the output from the Schrodinger equation (SE) and the GOAT EOMs are manipulated to return the objective function and any associated derivatives. Here we will use an already implemented reduction map that computes a projective SU measure called \"infidelity.\"","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"SE_reduce_map = SE_infidelity_reduce_map \nGOAT_reduce_map = GOAT_infidelity_reduce_map","category":"page"},{"location":"examples/example2/#Specifying-solver-and-optimization-options","page":"Working with QuantumOptics.jl","title":"Specifying solver and optimization options","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"# Define options for DifferentialEquations.jl (see DifferentialEquation docs for info)\nODE_options = (abstol = 1e-9, reltol= 1e-9, alg=Vern9())\n\n# Define the optimizer options from Optim.jl (See Optim.jl docs for info)\noptim_alg = Optim.LBFGS(linesearch=LineSearches.BackTracking()) # A Back-Tracking linesearch\noptim_options = Optim.Options(g_tol=1e-12,\n                            iterations=10,\n                            store_trace=true,\n                            show_trace=true, extended_trace=false, allow_f_increases=false)","category":"page"},{"location":"examples/example2/#Define-the-initial-guess-and-perform-an-optimization","page":"Working with QuantumOptics.jl","title":"Define the initial guess and perform an optimization","text":"","category":"section"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Here we will define our initial guess and specify which parameters are to be optimized, and how parallelization is to proceed:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"p0 = [0.25,ω,0.0] # The initial parameter guesses\nopt_param_inds = [1,2,3] # The parameters of the vector p0 to optimize -- all parameters in this case\nnum_params_per_GOAT = 3 # This parameter specifies how many derivatives are propogated in each GOAT EOMs","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"This num_params_per_GOAT variable specifies how many derivatives are propogated in each GOAT EOMs and informs parallelization. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"For example, if num_params_per_GOAT=5and there are 5 total parameters, then no parallelization is performed. In contrast, if num_params_per_GOAT=2 and there are 5 total parameters, then 3 processes are run in parallel: the first processor computes the EOMs for 2 parameters, the second process computes the EOMs for 2 parameters, and the third computes the EOMs for 1 parameter. ","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Next we put all of these parameters into a QOCParameters struct:","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"params = QOCParameters(ODE_options,SE_reduce_map,GOAT_reduce_map,optim_alg,optim_options; num_params_per_GOAT=num_params_per_GOAT)","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"Finally we run our optimization","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"res = find_optimal_controls(p0, opt_param_inds, sys, prob, params)\nres","category":"page"},{"location":"examples/example2/","page":"Working with QuantumOptics.jl","title":"Working with QuantumOptics.jl","text":"The converged infidelity should be around 7e-4, higher fidelities are possible. Explore the ansatz, control time, and other parameters to find a better optimum!","category":"page"},{"location":"core/Methods/#Core-Methods","page":"Core Methods","title":"Core Methods","text":"","category":"section"},{"location":"core/Methods/","page":"Core Methods","title":"Core Methods","text":"#something","category":"page"},{"location":"examples/example1/#Optimizing-a-gaussian-pulse-for-a-single-qubit","page":"Single qubit control","title":"Optimizing a gaussian pulse for a single qubit","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"This is perhaps the simplest example of a quantum optimal control problem. The physical task is to invert a qubit's population from he ground state ket0 to the orthogonal state ket1.","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Given a qubit Hamiltonian ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"H(t) = fracomega2sigma_z + Omega(t)sigma_x","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"one can determine analytically that there are a family of pulses which will accomplish the control task if the following criteria is met:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"int_0^t dtau Omega(tau) = pi","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"one common choice of Omega(t) is a Gaussian function (due to an array of reasons outside the scope of this example). ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"For this example we will fix the mean and standard deviation of the Gaussian to mu=T2 and sigma = T8. Therefore, we must determine the amplitude of the Gaussian in order to satisfy the topological criteraia and create population inversion.","category":"page"},{"location":"examples/example1/#Imports","page":"Single qubit control","title":"Imports","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"using GOAT\nusing LinearAlgebra, SparseArrays # For instantiating necessary matrices\nusing OrdinaryDiffEq # Load differetial equation algorithms\nusing Optim, LineSearches # Load optimization and linesearch algorithms","category":"page"},{"location":"examples/example1/#Defining-the-ControllableSystem","page":"Single qubit control","title":"Defining the ControllableSystem","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"We begin by defining the necessary operators for the Hamiltonian","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"σx = sparse(ComplexF64[0 1 ; 1  0])# The Pauli X matrix\nσy = sparse(ComplexF64[0 -im ; im 0]) # The Pauli Y matrix\nσz = sparse(ComplexF64[1 0 ; 0 -1]) # The Pauli Z matrix\nσI = sparse(ComplexF64[1 0 ; 0  1]) # The identity matrix","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we define the Hamiltonian parameters and the control basis operators","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"ω = 5*2pi # Setting a qubit frequency\nT = 10.0 # in arbitrary time units\nH0 = (ω/2)*σz # Setting the drift component of the Hamiltonian\nbasis_ops = [σx] # The control basis operator","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we choose a control ansatz specifying only a single basis function","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"N_basis_funcs = 1\nΩ(p,t,i) = gaussian_coefficient(p,t,i,N_basis_funcs)*cos(ω*t) # The control ansatz is a gaussian envelope of a cosine wave at frequency ω\n∂Ω(p,t,i,l) = ∂gaussian_coefficient(p,t,i,l,N_basis_funcs)*cos(ω*t) # The derivative of the control ansatz","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"and specify a rotating frame","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"rotating_frame_generator = -Diagonal(Matrix(H0)) # Moving into the interaction picture","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Finally we are able to specify our ControllableSystem:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"sys = ControllableSystem(H0, basis_ops, rotating_frame_generator, Ω, ∂Ω)","category":"page"},{"location":"examples/example1/#Defining-the-QOCProblem","page":"Single qubit control","title":"Defining the QOCProblem","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"First we define our target unitary operator","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"U_target = deepcopy(σx) # The targt unitary: X|0> = |1>","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Now, we provide a projector onto the computational and ancillary subspaces","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Pc = σI # The projector onto the computational subspace (which is the whole Hilbert space in this case)\nPa = 0.0*Pc # The projector onto the ancillary subspaces (which is a null operator in this case)\nprob = QOCProblem(U_target, T, Pc, Pa) # The quantum optimal control problem. ","category":"page"},{"location":"examples/example1/#Defining-a-reduction-map","page":"Single qubit control","title":"Defining a reduction map","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"A reduction map defines how the output from the Schrodinger equation (SE) and the GOAT EOMs are manipulated to return the objective function and any associated derivatives. Here we will use an already implemented reduction map that computes a projective SU measure called \"infidelity.\"","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"SE_reduce_map = SE_infidelity_reduce_map \nGOAT_reduce_map = GOAT_infidelity_reduce_map","category":"page"},{"location":"examples/example1/#Specifying-solver-and-optimization-options","page":"Single qubit control","title":"Specifying solver and optimization options","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"# Define options for DifferentialEquations.jl (see DifferentialEquations.jl docs for info)\nODE_options = (abstol = 1e-9, reltol= 1e-9, alg=Vern9())\n\n# Define the optimizer options from Optim.jl (See Optim.jl docs for info)\noptim_alg = Optim.LBFGS(linesearch=LineSearches.BackTracking()) # A Back-Tracking linesearch\noptim_options = Optim.Options(g_tol=1e-12,\n                            iterations=10,\n                            store_trace=true,\n                            show_trace=true, extended_trace=false, allow_f_increases=false)","category":"page"},{"location":"examples/example1/#Define-the-initial-guess-and-perform-an-optimization","page":"Single qubit control","title":"Define the initial guess and perform an optimization","text":"","category":"section"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Here we will define our initial guess and specify which parameters are to be optimized, and how parallelization is to proceed:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"p0 = [0.5,T/2,T/8] # The initial parameter guesses\nopt_param_inds = [1] # The parameters of the vector p0 to optimize (just the amplitude parameter -- p0[1] -- in this case)\nnum_params_per_GOAT = 1 ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"This num_params_per_GOAT variable specifies how many derivatives are propogated in each GOAT EOMs and informs parallelization. ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"For example, if num_params_per_GOAT=5and there are 5 total parameters, then no parallelization is performed. In contrast, if num_params_per_GOAT=2 and the  re are 5 total parameters, then 3 processes are run in parallel: the first processor computes the EOMs for 2 parameters, the second process computes the EOMs for 2 parameters, and the third computes the EOMs for 1 parameter. ","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Next we put all of these parameters into a QOCParameters struct:","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"params = QOCParameters(ODE_options,SE_reduce_map,GOAT_reduce_map,optim_alg,optim_options; num_params_per_GOAT=num_params_per_GOAT)","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"Finally we run our optimization","category":"page"},{"location":"examples/example1/","page":"Single qubit control","title":"Single qubit control","text":"res = find_optimal_controls(p0, opt_param_inds, sys, prob, params)\nres","category":"page"},{"location":"core/ReferenceFrames/#QOCProblem-struct-info","page":"QOCProblem struct info","title":"QOCProblem struct info","text":"","category":"section"},{"location":"core/ReferenceFrames/","page":"QOCProblem struct info","title":"QOCProblem struct info","text":"something","category":"page"},{"location":"background/Overview/#The-GOAT-method","page":"Overview","title":"The GOAT method","text":"","category":"section"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"The task of unitary quantum optimal control is to determine a set of control parameters vecalpha that realize a desired unitary evolution on the quantum system. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"Specifically, the dynamics under the Hamiltonian","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"H(vecalphat)  = H_0 + sum_i c_i(vecalphat) H_i","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"generates a unitary evolution","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"U(vecalphat) = mathcalTexp bigg int_0^t dtau H(vecalphatau) bigg","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"The task of optimal control is to determine a set of control parameters vecalpha^* and a control time T^* such that the system's evolution U(vecalpha^* T^*) approximates a desired unitary evolution U_target. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"The GOAT algorithm assumes that the each control function is described as a combination of a set of parametrized basis functions. This is a rather general definition and many choices for this decomposition can be made. Referred to as an ansatz, the choice of decomposition is typically informed by experimental considerations. One example is the expansion of each control function within an orthogonal function basis (like a polynomial basis or Fourier basis):","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"c_i(vecalphat) = sum_n^N alpha_n f_n(t)","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"While this optimization can be performed using gradient-free methods, optimization algorithms that utilize information about the gradient of the objective function w.r.t. the control parameters can yield much faster optimization. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"In order to utilize gradient-based optimization routines it is required that we compute the partial derivative of the unitary evolution with respect to a particular parameter alpha_n: partial_alpha_n U(vecalphaT). This can then be used (via the chain rule) to compute gradients of the objective function. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"We compute partial_alpha_n U(vecalphaT) by deriving a new differential equation from the Schrodinger equation:","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"ihbar partial_t U(vecalphat) = H(vecalphat)U(vecalphat)","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"by differentiating w.r.t alpha_n and utilizing the product rule","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"beginalign*\nihbarpartial_alpha_n partial_t U(vecalphat) = bigg(partial_alpha_n H(vecalphat) bigg) U(vecalphat) + bigg( H(vecalphat) bigg) partial_alpha_nU(vecalphat)\n= ihbarpartial_t partial_alpha_n U(vecalphat)\nendalign*","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"The last step utilizes the symmetry of the second derivative to obtain a differential equation for partial_alpha_n U(vecalphat). ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"To compute partial_alpha_n U(vecalphaT) at a final time T, we integrate the coupled differential equations:","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"\npartial_t\nbeginpmatrix\nU(vecalphat)\npartial_alpha_n U(vecalphat)\nendpmatrix\n\n= \n\nbeginpmatrix\nH(vecalphat)  0\npartial_alpha_n H(vecalphat)  H(vecalphat)\nendpmatrix\n\nbeginpmatrix\nU(vecalphat)\npartial_alpha_n U(vecalphat)\nendpmatrix\n","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"This coupled differential equation is referred to as the GOAT Equations of Motion (EOM). The initial conditions are U(vecalpha0) = I and partial_alpha_n U(vecalpha0) = 0  forall   alpha_n. It has a significant amount of internal structure which is specialized on in this package for efficient computation.","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"First, it depends only on a single parameter alpha_n thus, computing the gradient can be obtained through parallelization, solving a seperate GOAT EOM for each parameter to be optimized. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"Second, the action of the differential equation is highly structured: the upper triangle of the matrix is null and the diagonal of the matrix is H(vecalphat). Thus, storing this matrix, even in a sparse form is inefficient. Not only that, but the Hamiltonians of most physically realizable quantum systems are sparse which suggests that instantiating the action of the EOMs is not efficient in general. ","category":"page"},{"location":"background/Overview/","page":"Overview","title":"Overview","text":"Thus, this package specializes on these structures to implement parallelized, matrix-free implementations of the GOAT EOMs to optimize performance.","category":"page"},{"location":"core/QOCProblem/#QOCProblem-struct-info","page":"QOCProblem struct info","title":"QOCProblem struct info","text":"","category":"section"},{"location":"core/QOCProblem/","page":"QOCProblem struct info","title":"QOCProblem struct info","text":"something","category":"page"},{"location":"core/Ansatz/#Control-Ansatze","page":"Control Ansatze","title":"Control Ansatze","text":"","category":"section"},{"location":"core/Ansatz/","page":"Control Ansatze","title":"Control Ansatze","text":"In addition to the ansatz","category":"page"},{"location":"recommendations/#Recommendations-and-notes","page":"Recommendations","title":"Recommendations and notes","text":"","category":"section"},{"location":"recommendations/","page":"Recommendations","title":"Recommendations","text":"While not a direct dependency, the authors recommend using the QuantumOptics.jl to model the details of the quantum system (vectors/operators used in the computation). At the moment, GOAT.jl does not have methods that accept operator types from QuantumOptics.jl, but we do plan to add this functionality in the future. ","category":"page"},{"location":"#GOAT.jl-–-Gradient-Optimization-of-Analytic-Controls-in-Julia","page":"Home","title":"GOAT.jl – Gradient Optimization of Analytic Controls in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is a Julia implementation of the Gradient Optimization of Analytic conTrols (GOAT) optimal control methodology proposed in this paper by Machnes et al.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation only currently supports optimizing unitary evolution. Please peruse through the documentation and examples.","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please use the following citation for referencing this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"TBD","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this work is supported by the U.S. Department of Energy Office of Science (DOE-SC) Office of Advanced Scientific Computing Research (ASCR) Advancing Integrated Development Environments for Quantum Computing through Fundamental Research (AIDE-QC) project under contract number DE-AC02-06CH11357.","category":"page"}]
}
